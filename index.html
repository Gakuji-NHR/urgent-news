<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emergency Ticker | Yukiyama News</title>
  <style>
    :root{
      --band-bg: #000;
      --text-color: #fff;
      --label-bg: #c40000;
      --label-color: #fff;
      --font-min: 20px;
      --font-max: 56px;
      --letter-spacing: .5px;
      --speed-pps: 120;
      --pause-sec: 1.2;
    }

    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:transparent}

    .band{position:relative;width:100%;height:100%;background:var(--band-bg);color:var(--text-color);display:flex;overflow:hidden;}

    .label{flex:0 0 auto;display:flex;align-items:center;justify-content:center;padding:0 20px;background:var(--label-bg);color:var(--label-color);font-weight:800;letter-spacing:1px;text-transform:uppercase;font-size:clamp(14px,2.2vw,32px);}

    .viewport{position:relative;flex:1 1 auto;overflow:hidden;display:flex;align-items:center;padding:10% 0;}

    .content{position:absolute;white-space:nowrap;will-change:transform;display:block;font-size:clamp(var(--font-min), 3vw, var(--font-max));line-height:1.3;letter-spacing:var(--letter-spacing)}

    .chunk{display:block}
    .line{display:block}

    .content, .label{text-shadow: 0 2px 4px rgba(0,0,0,.6), 0 0 10px rgba(0,0,0,.35)}

    .pulse {animation: pulse 1.5s ease-in-out infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.6}}

    @keyframes marquee {
      0%   { transform: translateX(0); }
      100% { transform: translateX(var(--to-x)); }
    }

    .hidden{display:none}
  </style>
</head>
<body>
  <div class="band">
    <div class="label pulse">UPDATES<br>最新情報</div>
    <div class="viewport">
      <div id="bufA" class="content"></div>
      <div id="bufB" class="content"></div>
      <div id="staticFit" class="content hidden"></div>
    </div>
  </div>

  <script>
    const CONFIG = {
      skiareaId: 379,
      apiBase: 'https://web-api.yukiyama.biz/web-api/news/backward',
      limit: 1,
      enLang: 'en',
      jaLang: 'ja',
      speedPPS: parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--speed-pps')) || 120,
      pauseSec: parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--pause-sec')) || 1.0,
      fallbackEN: 'Service disruption due to severe weather and gondola adjustment. Tickets remain valid on other operating days in 2025. For refunds, please contact us.',
      fallbackJA: '悪天候およびゴンドラ調整のため本日の営業を中止します。チケットは2025年シーズン営業日に振替可能です。返金希望の方はご連絡ください。',
    };

    const els = {
      bufA: document.getElementById('bufA'),
      bufB: document.getElementById('bufB'),
      staticFit: document.getElementById('staticFit'),
      viewport: null,
    };
    els.viewport = els.bufA.parentElement;

    async function fetchNewsByLang(lang){
      const params = new URLSearchParams({ skiareaId: String(CONFIG.skiareaId) });
      if (CONFIG.limit) params.set('limit', String(CONFIG.limit));
      if (lang) params.set('lang', lang);
      const url = `${CONFIG.apiBase}?${params.toString()}`;
      const res = await fetch(url, { method:'GET' });
      if (!res.ok) throw new Error('HTTP '+res.status);
      const data = await res.json();
      const list = Array.isArray(data) ? data : (Object.keys(data).every(k=>/^\d+$/.test(k)) ? Object.keys(data).sort((a,b)=>a-b).map(k=>data[k]) : [data]);
      return list[0] || null;
    }

    function buildTickerText(enItem, jaItem){
      const enTitle = enItem?.title || 'Notice';
      const enMsg   = (enItem?.message || CONFIG.fallbackEN).replace(/\s+/g,' ').trim();
      const jaTitle = jaItem?.title || 'お知らせ';
      const jaMsg   = (jaItem?.message || CONFIG.fallbackJA).replace(/\s+/g,' ').trim();
      return { en: `${enTitle}: ${enMsg}`, ja: `${jaTitle}: ${jaMsg}` };
    }

    function mountContent(enText, jaText){
      const makeChunk = () => {
        const wrap = document.createElement('div');
        wrap.className = 'chunk';
        const enLine = document.createElement('div');
        enLine.className = 'line';
        enLine.textContent = `EN ${enText}`;
        const jaLine = document.createElement('div');
        jaLine.className = 'line';
        jaLine.textContent = `JA ${jaText}`;
        wrap.append(enLine, jaLine);
        return wrap;
      };

      els.bufA.innerHTML = els.bufB.innerHTML = els.staticFit.innerHTML = '';
      els.bufA.appendChild(makeChunk());
      els.bufB.appendChild(makeChunk());

      const totalWidth = measureContentWidth(els.bufA);
      const vw = els.viewport.clientWidth;
      if (totalWidth <= vw * 0.92){
        els.bufA.style.animation = els.bufB.style.animation = 'none';
        els.bufA.style.transform = els.bufB.style.transform = 'translateX(0)';
        els.bufA.classList.add('hidden');
        els.bufB.classList.add('hidden');
        els.staticFit.classList.remove('hidden');
        els.staticFit.innerHTML = `<div class="line">EN ${enText}</div><div class="line">JA ${jaText}</div>`;
        return;
      }
      const distance = totalWidth + vw;
      const dur = distance / CONFIG.speedPPS;
      document.documentElement.style.setProperty('--to-x', `-${distance}px`);
      const keyframes = `marquee ${dur}s linear infinite`;
      els.bufA.style.left = `${vw}px`;
      els.bufB.style.left = `${vw + totalWidth}px`;
      els.bufA.style.animation = els.bufB.style.animation = keyframes;
      if (CONFIG.pauseSec > 0){ setupLoopPause([els.bufA, els.bufB], dur, CONFIG.pauseSec); }
    }

    function setupLoopPause(nodes, duration, pause){
      nodes.forEach((n)=>{
        let acc = 0; let playing = true; let last = performance.now();
        const tick = (t)=>{
          const dt = (t - last)/1000; last = t; if (playing){acc += dt;}
          if (acc >= duration){ acc = 0; playing = false; const prev = n.style.animationPlayState; n.style.animationPlayState = 'paused'; setTimeout(()=>{ playing = true; n.style.animationPlayState = prev || 'running'; }, pause*1000); }
          requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      });
    }

    function measureContentWidth(el){
      const rect = el.getBoundingClientRect();
      return Math.ceil(rect.width || 0);
    }

    async function loadAndRender(){
      try{
        const [en, ja] = await Promise.all([
          fetchNewsByLang(CONFIG.enLang).catch(()=>null),
          fetchNewsByLang(CONFIG.jaLang).catch(()=>null),
        ]);
        const text = buildTickerText(en, ja);
        mountContent(text.en, text.ja);
      }catch(err){
        console.error(err);
        mountContent(CONFIG.fallbackEN, CONFIG.fallbackJA);
      }
    }

    loadAndRender();
    setInterval(loadAndRender, 60 * 1000);

    window.addEventListener('resize', ()=>{ loadAndRender(); });
  </script>
</body>
</html>
